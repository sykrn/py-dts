# Is there real randomness in computers?
Another module worth mentioning is the one named `random`.

It delivers some mechanisms allowing you to operate with `pseudorandom numbers`.

Note the prefix `pseudo` - the numbers generated by the modules may look random in the sense that you cannot predict their subsequent values, but don't forget that they all are calculated using very refined algorithms.

The algorithms aren't random - they are deterministic and predictable. Only those physical processes which run completely out of our control (like the intensity of cosmic radiation) may be used as a source of actual random data. Data produced by deterministic computers cannot be random in any way.

A random number generator takes a value called a `seed`, treats it as an input value, calculates a "random" number based on it (the method depends on a chosen algorithm) and produces a `new seed value`.

The length of a cycle in which all seed values are unique may be very long, but it isn't infinite - sooner or later the seed values will start repeating, and the generating values will repeat, too. This is normal. It's a feature, not a mistake, or a bug.

The initial seed value, set during the program start, determines the order in which the generated values will appear.

The random factor of the process may be `augmented by setting the seed with a number taken from the current time` - this may ensure that each program launch will start from a different seed value (ergo, it will use different random numbers).

Fortunately, such an initialization is done by Python during module import.

==================================================================
# Selected functions from the random module
`The random function`

The most general function named `random()` (not to be confused with the module's name) `produces a float number x coming from the range (0.0, 1.0)` - in other words: (0.0 <= x < 1.0).

The example program below will produce five pseudorandom values - as their values are determined by the current (rather unpredictable) seed value, you can't guess them:
```py
from random import random

for i in range(5):
    print(random())
```

Run the program. This is what we've got:
```s
0.9535768927411208
0.5312710096244534
0.8737691983477731
0.5896799172452125
0.02116716297022092
```

# The seed function

The `seed()` function is able to directly `set the generator's seed`. We'll show you two of its variants:

  - `seed()` - sets the seed with the current time;
  - `seed(int_value)` - sets the seed with the integer value `int_value`.

We've modified the previous program - in effect, we've removed any trace of randomness from the code:
```py
from random import random, seed

seed(0)

for i in range(5):
    print(random())
```

Due to the fact that the seed is always set with the same value, the sequence of generated values always looks the same.

Run the program. This is what we've got:
```s
0.844421851525
0.75795440294
0.420571580831
0.258916750293
0.511274721369
```

And you?

Note: your values may be slightly different than ours if your system uses more precise or less precise floating-point arithmetic, but the difference will be seen quite far from the decimal point.

==================================================================
# Selected functions from the random module: continued
`The randrange and randint functions`

If you want integer random values, one of the following functions would fit better:

  - `randrange(end)`
  - `randrange(beg, end)`
  - `randrange(beg, end, step)`
  - `randint(left, right)`

The first three invocations will generate an integer taken (pseudorandomly) from the range (respectively):

  - `range(end)`
  - `range(beg, end)`
  - `range(beg, end, step)`

Note the implicit `right-sided exclusion!`

The last function is an equivalent of `randrange(left, right+1)` - it generates the integer value `i`, which falls in the range [left, right] (no exclusion on the right side).

Look at the code in the editor. This sample program will consequently output a line consisting of three zeros and either a zero or one at the fourth place.
```py
from random import randrange, randint

print(randrange(1), end=' ')
print(randrange(0, 1), end=' ')
print(randrange(0, 1, 1), end=' ')
print(randint(0, 1))
```
```s
0 0 0 0
```

==================================================================
# Selected functions from the random module: continued
The previous functions have one important disadvantage - they may produce repeating values even if the number of subsequent invocations is not greater than the width of the specified range.

Look at the code below - the program very likely outputs a set of numbers in which some elements are not unique:
```py
from random import randint

for i in range(10):
    print(randint(1, 10), end=',')
```

This is what we got in one of the launches:
```s
9,4,5,4,5,8,9,4,8,4,
```

# The choice and sample functions

As you can see, this is not a good tool for generating numbers in a lottery. Fortunately, there is a better solution than writing your own code to check the uniqueness of the "drawn" numbers.


It's a function named in a very suggestive way - `choice`:

  - `choice(sequence)`
  - `sample(sequence, elements_to_choose)`

The first variant chooses a "random" element from the input sequence and returns it.

The second one builds a list (a sample) consisting of the `elements_to_choose` element "drawn" from the input sequence.

In other words, the function chooses some of the input elements, returning a list with the choice. The elements in the sample are placed in random order. Note: the `elements_to_choose` must not be greater than the length of the input sequence.

Look at the code below:
```py
from random import choice, sample

my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(choice(my_list))
print(sample(my_list, 5))
print(sample(my_list, 10))
```

Again, the output of the program is not predictable. Our results looked like this:
```s
4
[3, 1, 8, 9, 10]
[10, 8, 5, 1, 6, 4, 3, 9, 7, 2]
```

